package common

import (
	"math/big"
	"time"
)

// 구조체를 공개하면 new()로 직접 생성해서 초기화가 적절하게 되지 않는 경우가 발생함.
// 항상 적절한 초기화가 되도록 구조체 자체는 외부에 숨기고,
// 생성자(N으로 시작됨)를 통해서만 생성할 수 있도록 하여, 생성자에서 적절한 초기화가 이루어지도록 함.
// 구조체를 사용하기 위해서는 외부에 공개된 관련 인터페이스를 사용함.
// 예) SC정수를 사용하기 위해서 NC정수로 생성해서 C정수 인터페이스를 통해서 사용.
// Go언어에는 생성자가 따로 없어서 이런 식으로 해결함.

// 상수형 정수. int가 있으니 V정수는 필요없음.
type C정수 interface {
	I상수형
	I큰정수형
	I정밀수형
	I문자열형
	G값() int64
}

// 상수형 부호없는 정수. uint64가 있으니 V부호없는_정수는 필요없음.
type C부호없는_정수 interface {
	I상수형
	I큰정수형
	I정밀수형
	I문자열형
	G값() uint64
}

// 상수형 실수. float64가 있으니 V실수는 필요없음.
type C실수 interface {
	I상수형
	I정밀수형
	I문자열형
	G값() float64
}

// 상수형 문자열. string이 있으니 V문자열은 필요없음.
type C문자열 interface {
	I상수형
	I문자열형
	G값() string
}

// 상수형 참거짓. bool이 있으니 V참거짓은 필요없음.
type C참거짓 interface {
	I상수형
	I문자열형
	G값() bool
}

/****************************
*            시점
****************************/

// 시점 기본 인터페이스
type I시점 interface { G값() time.Time }

// 상수형 시점
type C시점 interface {
	I상수형
	I시점
}

// 변수형 시점
type V시점 interface {
	I변수형
	I시점
	S값(값 time.Time)
	G상수형() C시점
}

/************************
*       큰 정수
*************************/

// 큰 정수 기본 인터페이스
type I큰정수 interface {
	I큰정수형
	I정밀수형
	I문자열형
	G값() big.Int	
	G정수값() int64
}

// 상수형 큰 정수
type C큰정수 interface {
	I상수형
	I큰정수
	G변수형() V큰정수
}

// 변수형 큰 정수
type V큰정수 interface {
	I변수형
	I큰정수
	S값(값 int64)
	S값Big(값 big.Int)
	G상수형() C큰정수
}

/************************
*           정밀수
*************************/

/*
	I정밀수 -> I고정소숫점 -> I통화 
	
	1. big.Rat의 상수형. 
		구조체 전체를 복사하지 않고, 포인터만 공유하므로 메모리 절약하는 동시에,
		다수의 goroutine에서 공유하더라도 데이터 공유에 따른 복잡한 문제가 발생하지 않도록 방지.
		(모든 C로 시작하는 상수형 자료형의 궁극적인 존재 이유임.)
	2. I통화, I고정소숫점의 반환값 형식인 big.Rat의 사용 편의성 향상.
	3. big.Rat의 연산 메소드를 한글화 하여 소스코드 가독성을 높임.
*/
// 정밀수 기본 인터페이스
type I정밀수 interface {
	I정밀수형
	I문자열형
	G값() big.Rat
	G실수값() float64
	G반올림값(소숫점_이하_자릿수 int) float64
	G반올림_문자열(소숫점_이하_자릿수 int) string	
	G부호() int	// 음수 -1, 제로 0, 양수 1.
}

// 상수형 정밀수
type C정밀수 interface {
	I상수형
	I정밀수
	//G변수형() V정밀수		// 부작용이 있을까봐 일단 제거함.
}

// 변수형 정밀수
type V정밀수 interface {
	I변수형
	I정밀수
	G상수형() C정밀수
	S값(값 float64)
	S값Big(값 big.Rat)
	
	// 연산 함수
	// S로 시작하는 연산 함수는 '메소드 연속 호출'(메소드 체이닝) 기법을 사용하기 위해서 
	//   자기 자신을 결과값으로 설정하고 자기 자신을 반환한다.
	// 예 : v정밀수.S빼기(v1, v2).S셀프_곱하기(v3).S셀프_절대값()
	S절대값(값 I정밀수) V정밀수
	S더하기(값1 I정밀수, 값2 I정밀수) V정밀수
	S빼기(값1 I정밀수, 값2 I정밀수) V정밀수
	S곱하기(값1 I정밀수, 값2 I정밀수) V정밀수
	S나누기(값1 I정밀수, 값2 I정밀수) V정밀수
	S역수(값 I정밀수) V정밀수
	S반대부호값(값 I정밀수) V정밀수
	
	S셀프_절대값() V정밀수
	S셀프_더하기(값 I정밀수) V정밀수
	S셀프_빼기(값 I정밀수) V정밀수
	S셀프_곱하기(값 I정밀수) V정밀수
	S셀프_나누기(값 I정밀수) V정밀수
	S셀프_역수() V정밀수
	S셀프_반대부호값() V정밀수
}

/********************************************
*         고정소숫점 (소수점이 있으니 당연히 실수임.)
********************************************/

/*
*	I고정소숫점 -> I통화
*	'I고정소숫점'을 사용하는 이유는 'I통화'에서 금액을 정확하게 표현하고, 계산의 오차를 방지하기 위해서임.
*	반환값은 Go언어에 내장된 데이터 형식만을 사용하여 API의 안정성을 도모함.
*	내부적으로는 외부 라이브러리(speter의 decimal 패키지)를 사용할 계획임. (아직 미완성)
*	
*	현재 내부적으로 big.Rat을 사용하고 있지만, 
*	향후 금액 계산의 정확성을 위하여 speter decimal 패키지로 전환할 계획임.
*	speter의 decimal 패키지는 나눗셈 나머지값의 처리를 올림, 내림, 반올림, 기타 다양한 방식으로
*	지정할 수 있어서 금액 계산의 정확성을 기하는 데 필요하다고 판단됨.  
*	내부 구현이 바뀌더라도 입력값 및 반환값의 형식은 유지되므로 'I고정소숫점' 사용자에게는 영향이 없을 것임.
*	(인터페이스의 원래 목적이 내부 구현이 바뀌어도 사용자에게 지장이 없도록 하는 것임.)
*/
// 고정소숫점 기본 인터페이스
type I고정소숫점 interface {
	I정밀수형
	I문자열형
	G값() C고정소숫점
	G소숫점_이하_자릿수() int
	G실수() float64
	G원본() big.Rat
	G금액_문자열() string	// 세자리 마다 콤마로 분리된 문자열
}

// 상수형 고정소숫점
type C고정소숫점 interface {
	I상수형
	I고정소숫점
	G변수형() V고정소숫점
}

// 변수형 고정소숫점
type V고정소숫점 interface {
	I변수형
	I고정소숫점
	S값(값 float64, 소숫점_이하_자릿수 int)
	S값Big(값 big.Rat, 소숫점_이하_자릿수 int)
	G상수형() C고정소숫점
	
	// 연산 함수
	// S로 시작하는 연산 함수는 '메소드 연속 호출'(메소드 체이닝) 기법을 사용하기 위해서 
	//   자기 자신을 결과값으로 설정하고 자기 자신을 반환한다.
	// 예 : v고정소숫점.S빼기(v1, v2).S셀프_곱하기(v3).S셀프_절대값()
	S절대값(값 I고정소숫점) V고정소숫점
	S더하기(값1 I고정소숫점, 값2 I고정소숫점) V고정소숫점
	S빼기(값1 I고정소숫점, 값2 I고정소숫점) V고정소숫점
	S곱하기(값1 I고정소숫점, 값2 I고정소숫점) V고정소숫점
	S나누기(값1 I고정소숫점, 값2 I고정소숫점) V고정소숫점
	S역수(값 I고정소숫점) V고정소숫점
	S반대부호값(값 I고정소숫점) V고정소숫점
	
	S셀프_절대값() V고정소숫점
	S셀프_더하기(값 I고정소숫점) V고정소숫점
	S셀프_빼기(값 I고정소숫점) V고정소숫점
	S셀프_곱하기(값 I고정소숫점) V고정소숫점
	S셀프_나누기(값 I고정소숫점) V고정소숫점
	S셀프_역수() V고정소숫점
	S셀프_반대부호값() V고정소숫점
}

/**************************************************
*                복합 상수형 
***************************************************
*  내부 타입은 변하지만, 값 자체는 상수형임.
*
*  여러가지 타입의 데이터를 주고 받을 때,
*  가변형의 슬라이스나 맵으로 주고 받으면,
*  한꺼번에 주고 받을 수 있어서 관리도 쉽고,
*  내부값을 바꿀 수 없기 때문에 데이터 공유로 인한 문제도 
*  사전에 예방할 수 있다.
***************************************************
*/
// 복합 상수형 기본 인터페이스
type C복합_상수형 interface {
	I상수형
	G값() I상수형
	G형식() string	
	G참거짓() (bool, error)
	G정수() (int64, error)
	G부호없는_정수() (uint64, error)
	G실수() (float64, error)
	G문자열() (string, error)
	G시점() (time.Time, error)
	G큰정수() (big.Int, error)
	G정밀수() (big.Rat, error)
	G고정소숫점() (C고정소숫점, error)
	G통화() (C통화, error)	
}

/**************************************************
*                복합 가변형 
***************************************************
*  내부 타입도 변하고, 값 자체도 변수형임.
*
*  여러가지 타입의 데이터를 주고 받을 때,
*  상수형이 아닌 여러가지 데이터를 한꺼번에 주고 받을 때 사용.
*  전달 후 내부값이 변할 수 있으니, 되도록 사용하지 "!않는!" 편이 좋음.
*  혹은 여러 함수가 순차적인 공동 작업을 하는 경우에는 괜찮을 수도 있으나,
*  Go언어 특유의 goroutine의 동시성 때문에 조심하고,
*  채널을 통해서만 주고 받는 게 좋음.
*
*  이렇게 변경 가능한 데이터의 공유에 따른 문제를 해결하려면,
*  sync.RWMutex 를 이용하거나,
*  읽고 쓰는 별도의 goroutine을 두고, 
*  다른 모든 goroutine은 채널을 통해서 읽고 써야 
*  동시 접근에 따른 문제를 원천적으로 봉쇄할 수 있음.
***************************************************
*/
// 복합 상수형 기본 인터페이스
type V복합_가변형 interface {
	I변수형
	G값() I변수형
	G형식() string
	G종류() reflect.Kind
	G상수형임() bool
	S값(값 I변수형)	// 값을 변경할 수 있음.
	
	G참거짓() (bool, error)
	G정수() (int64, error)
	G부호없는_정수() (uint64, error)
	G실수() (float64, error)
	G문자열() (string, error)
	G시점() (time.Time, error)
	G큰정수() (big.Int, error)
	G정밀수() (big.Rat, error)
	G고정소숫점() (C고정소숫점, error)
	G통화() (C통화, error)
}