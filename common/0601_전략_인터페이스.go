package common

// TODO
type I로그분석 struct{}
type I백테스팅 struct{} // 모의서버가 곧 백테스팅이 될 듯 하다.
type I모의서버 struct{}

// 파라메터만 다르고, 로직은 같은 전략을 하나로 묶어서 관리하기 위함
type I전략 interface {
	I식별코드
	
	G포트폴리오() I포트폴리오
	G위험관리() I위험관리
	
	// 테스트를 위해서 구현하지 않은 기능이나 인터페이스는 코멘트 처리.
	
	/*	
	// 라이프 싸이클
	F실행(서버 I서버)
	F가격정보처리() // 가격정보채널 처리하면서 초도매수신호 발생. 후속신호는 각 초도신호에서 발생.
	F탈출()
	F종료() // 종료채널 close로 대체하면 필요없을 듯.
	
	// 채널
	G가격정보채널() chan *C가격정보
	G신호채널() chan *C신호 // I신호가 보내온 후속신호를 받는 채널
	//G주문채널() chan *C주문	// 주문수신은 서버에서 관리한다.
	G비상탈출채널() chan uint8
	G종료채널() chan uint8
	
	// 하위 전략 관리 
	// 이걸 외부에 공개하는 게 맞는 걸까? 
	// 외부에는 정보를 주고받는 채널만 공개하고 실행하는 메소드는 공개하지 않는 게 맞을 듯 한데.
	G하위_전략_모음() []*I전략
	F가격정보_배포()
	F탈출신호_배포()
	F종료신호_배포() // 종료채널 close를 하는 것으로 대체하면 필요없을 듯.
	
	// 신호 관리
	G미청산신호_모음() []*C신호
	F가격정보_배포() // 미청산신호에 가격정보 배포. 하위 전략에 배포하는 것과 중복됨.
	
	// 주문관리
	F주문전송(주문 *C주문) uint64
	F체결여부확인(주문 *C주문) uint64
	
	// 주문 처리결과 관리
	G주문처리결과모음_미청산신호() []*C주문처리결과
	F주문처리결과기록(주문처리결과 *C주문처리결과)
	*/
}

// 신호
type I초도신호 interface {
	I식별코드
	I초도신호_전략관리
	I초도신호_라이프싸이클관리
	I초도신호_채널관리
}

type I초도신호_전략관리 interface {
	전략() I전략
}

type I초도신호_라이프싸이클관리 interface {
	M실행()    // select 루프 도는 goroutine.
	가격정보처리() // 가격정보채널 처리하면서 후속신호(추가매수신호 및 청산신호) 발생.
}

type I초도신호_채널관리 interface {
	G가격정보채널() chan *C가격정보
	G비상탈출채널() chan uint8
	G종료채널() chan uint8 // 전략에서 한꺼번에 관리하면 굳이 필요없을 듯.
	//G주문채널() chan *C주문	// 주문수신은 서버에서 관리한다.
	//G주문처리결과채널() chan *C주문처리결과	// 주문전송 및 처리결과 처리는 전략에서 한다.
	// 신호가 발생할 경우 주문을 낼 건지 말 건지는 전략의 위험관리 모듈에서 한다.
	// 주문처리결과도 주문을 전송한 전략에서 함께 관리하는 게 맞는 듯 하다.
}

/*	모 전략(그룹) - 하위 전략 인스턴스 (초도신호, 주문전송, 주문처리결과 담당) - 초도신호(후속신호 담당)
	 |
	서버 : 전략관리모듈, 가격정보제공모듈, 주문처리모듈, 증권사모듈등을 가진다.
		  증권사모듈을 가상모듈로 교체하면 백테스팅 시뮬레이션이 된다.

	가격정보의 흐름 : 증권사모듈 -> 가격정보제공모듈 -> (서버 ->) 전략그룹 -> 전략, 초도신호
	주문정보의 흐름 : 전략(초도신호), 초도신호(후속신호) -> (서버 ->) 주문처리모듈 -> 증권사모듈
	서버는 채널의 위치를 중개해 줄 뿐, 실제 가격정보와 주문정보는 서버를 거치는 것은 아니다.
*/
