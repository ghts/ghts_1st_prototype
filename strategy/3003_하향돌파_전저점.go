package base

import (
	"errors"
	"fmt"
	"log"
	"math"
	공통 "pts/common"
	"time"
)

func 저점_찾기_도우미(일일가격정보_모음 *공통.S일일가격정보_모음, 시작시점 time.Time, 종료시점 time.Time) (error, *공통.C일일가격정보) {
	if 시작시점.After(종료시점) {
		에러 := errors.New("저점_찾기_도우미() : 시작시점이 종료시점 이후 입니다.")
		return 에러, nil
	}

	일일가격정보_내용 := 일일가격정보_모음.G내용()

	var 최저조정가_초기값 float64 = 1.0E+100 // 초기값으로 아주 큰 값을 설정.
	var 저점 *공통.C일일가격정보 = nil

	최저조정가 := 최저조정가_초기값

	// DEBUGGING
	//log.Println("")
	//log.Println("***********************")
	//log.Println("저점_찾기_도우미() 시작 지점")
	//log.Println("***********************")

	for 반복횟수 := 0; 반복횟수 < 100; 반복횟수++ { // 최저조정가 초기값이 충분히 크지 않을 경우에 대비.
		for _, 일일가격정보 := range 일일가격정보_내용 {
			if 일일가격정보.G일자().Before(시작시점) {
				continue
			}
			if 일일가격정보.G일자().After(종료시점) {
				break
			}

			// DEBUGGING
			//log.Println("일일가격정보 :", 일일가격정보.G일자(), 일일가격정보.G조정시가(), 일일가격정보.G조정종가())

			if 일일가격정보.G조정시가() <= 0.0 ||
				math.IsNaN(일일가격정보.G조정시가()) ||
				math.IsInf(일일가격정보.G조정시가(), 0) ||
				일일가격정보.G조정종가() <= 0.0 ||
				math.IsNaN(일일가격정보.G조정종가()) ||
				math.IsInf(일일가격정보.G조정종가(), 0) {
				continue
			}

			if 저점 == nil {
				저점 = 일일가격정보
			}

			if 일일가격정보.G조정시가() < 최저조정가 {
				최저조정가 = 일일가격정보.G조정시가()
				저점 = 일일가격정보
			}

			if 일일가격정보.G조정종가() < 최저조정가 {
				최저조정가 = 일일가격정보.G조정종가()
				저점 = 일일가격정보
			}
		}

		//fmt.Println(반복횟수, 저점.G조정시가(), 저점.G조정종가())

		if 저점 == nil {
			// 이건 무슨 케이스이지?
			if len(일일가격정보_내용) == 0 {
				log.Println("저점_찾기_도우미() : 일일가격정보 내용이 없습니다.")
			} else {
				log.Println("저점_찾기_도우미() : 예상치 못한 경우. 저점이 nil입니다. .")
			}
		}

		//log.Println("저점 :",  저점.G일자(), 저점.G조정시가(), 저점.G조정종가(), "최저조정가_초기값", 최저조정가_초기값)

		if 저점.G조정시가() < 최저조정가_초기값 ||
			저점.G조정종가() < 최저조정가_초기값 {
			// 저점을 제대로 찾았음.
			// (최저조정가 초기값이 충분히 크지 않아서, 저점을 제대로 못 잦은 경우가 아님.)
			return nil, 저점
		}

		// 최저조정가 초기값이 충분히 크지 않아서, 저점을 제대로 못 잦은 경우이라고 가정함.
		// 최저조정가 초기값을 아주 크게 만든 후 (100배 크게 만듦) , 다시 저점을 검색함.
		log.Println("저점_찾기_도우미(). 저점을 찾지 못함. 최저조정가가 충분히 크지 않을 가능성 있음. 반복횟수 :", 반복횟수)
		최저조정가_초기값 = 최저조정가_초기값 * 100
		최저조정가 = 최저조정가_초기값
	}

	// 반복 후에도 여전히 저점을 찾지 못함.
	// 최저조정가의 초기값이 충분히 크지 않아서가 아닌 다른 이유일 가능성이 높음.
	에러 := errors.New("저점_찾기_도우미(). 반복 후에도 여전히 저점을 찾지 못함")

	return 에러, 저점
}

func F저점_찾기_단순버전(일일가격정보_모음 *공통.S일일가격정보_모음, 기준일 time.Time, 검색범위 int) (error, *공통.C일일가격정보) {
	return F저점_찾기_선행기간_확인(일일가격정보_모음, 기준일, 검색범위, 0)
}

func F저점_찾기(일일가격정보_모음 *공통.S일일가격정보_모음, 기준일 time.Time, 검색범위 int) (error, *공통.C일일가격정보) {
	return F저점_찾기_선행기간_확인(일일가격정보_모음, 기준일, 검색범위, 1)
}

func F저점_찾기_선행기간_확인(일일가격정보_모음 *공통.S일일가격정보_모음,
	기준일 time.Time, 검색범위 int, 선행기간 int) (error, *공통.C일일가격정보) {
	if 검색범위 < 0 {
		에러 := fmt.Errorf("F저점_찾기_선행기간_확인() : 검색범위가 0 혹은 음수입니다. 검색범위 : %v", 검색범위)

		return 에러, nil
	}

	if 선행기간 < 0 {
		에러 := fmt.Errorf("F저점_찾기_선행기간_확인() : 선행기간이 음수입니다. 선행기간 : %v", 선행기간)

		return 에러, nil
	}

	시작시점 := 기준일.AddDate(0, 0, -1*검색범위)
	종료시점 := 기준일

	에러, 저점 := 저점_찾기_도우미(일일가격정보_모음, 시작시점, 종료시점)

	if 에러 != nil {
		return 에러, nil
	}

	// 선행저점에 무관한 단순 저점 찾기일 경우 여기서 종료.
	if 선행기간 == 0 {
		return nil, 저점
	}

	// 최저조정가 초기화
	var 최저조정가 float64 = 0.0

	if 저점.G조정시가() > 저점.G조정종가() {
		최저조정가 = 저점.G조정시가()
	} else {
		최저조정가 = 저점.G조정종가()
	}

	// 현재 저점이 선행기간 동안에도 저점인지 확인.
	for 반복횟수 := 0; 반복횟수 < 1000; 반복횟수++ {
		for 선행기간_확장 := 0; 선행기간_확장 < 1000; 선행기간_확장++ {
			시작시점 = 저점.G일자().AddDate(0, 0, -1*(선행기간+선행기간_확장))
			종료시점 = 저점.G일자()

			if !종료시점_이전에_정상적인_가격데이터_존재여부_확인(일일가격정보_모음, 시작시점, 종료시점) {
				// 정상가격정보 없음. 선행기간 늘려서 재검색
				continue
			}

			에러, 신저점 := 저점_찾기_도우미(일일가격정보_모음, 시작시점, 종료시점)

			if 에러 != nil {
				log.Println("F저점_찾기_선행기간_확인(), 저점_찾기_도우미() 호출 후 에러발생, 반복횟수", 반복횟수, ", 선행기간_확장", 선행기간_확장)
				return 에러, nil
			}

			if 최저조정가 <= 신저점.G조정시가() &&
				최저조정가 <= 신저점.G조정종가() {
				// 현재 저점이 진짜 저점이 맞음
				return nil, 저점
			}

			// 새로운 저점을 찾았음.
			// 저점과 최저조정가를 새로 설정한 후, 처음부터 다시 선행저점 있는 지 확인
			저점 = 신저점

			if 저점.G조정시가() < 저점.G조정종가() {
				최저조정가 = 저점.G조정시가()
			} else {
				최저조정가 = 저점.G조정종가()
			}
		}
	}

	// 저점을 못 찾았음.
	에러 = errors.New("F저점_찾기_선행기간_확인() : 선행기간을 만족하는 저점을 찾지 못함.")

	return 에러, nil
}
