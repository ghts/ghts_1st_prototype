package base

import (
	"errors"
	"fmt"
	"log"
	"math"
	공통 "pts/common"
	"time"
)

func 고점_찾기_도우미(일일가격정보_모음 *공통.S일일가격정보_모음, 시작시점 time.Time, 종료시점 time.Time) (error, *공통.C일일가격정보) {
	if 시작시점.After(종료시점) {
		에러 := errors.New("고점_찾기_도우미() : 시작시점이 종료시점 이후 입니다.")
		return 에러, nil
	}

	일일가격정보_내용 := 일일가격정보_모음.G내용()

	var 최고조정가_초기값 float64 = 0.0
	var 고점 *공통.C일일가격정보 = nil

	최고조정가 := 최고조정가_초기값

	for _, 일일가격정보 := range 일일가격정보_내용 {
		if 일일가격정보.G일자().Before(시작시점) {
			continue
		}
		if 일일가격정보.G일자().After(종료시점) {
			break
		}

		if 일일가격정보.G조정시가() <= 0.0 ||
			math.IsNaN(일일가격정보.G조정시가()) ||
			math.IsInf(일일가격정보.G조정시가(), 0) ||
			일일가격정보.G조정종가() <= 0.0 ||
			math.IsNaN(일일가격정보.G조정종가()) ||
			math.IsInf(일일가격정보.G조정종가(), 0) {
			continue
		}

		if 고점 == nil {
			고점 = 일일가격정보
		}

		if 일일가격정보.G조정시가() > 최고조정가 {
			최고조정가 = 일일가격정보.G조정시가()
			고점 = 일일가격정보
		}

		if 일일가격정보.G조정종가() > 최고조정가 {
			최고조정가 = 일일가격정보.G조정종가()
			고점 = 일일가격정보
		}
	}

	if 최고조정가 == 최고조정가_초기값 {
		// 제대로 된 고점을 찾지 못합.
		에러 := errors.New("고점_찾기_도우미() : 최고조정가가 0임. 제대로 된 고점을 찾지 못했음.")
		return 에러, 고점
	}

	return nil, 고점
}

func F고점_찾기_단순버전(일일가격정보_모음 *공통.S일일가격정보_모음, 기준일 time.Time, 검색범위 int) (error, *공통.C일일가격정보) {
	return F고점_찾기_선행기간_확인(일일가격정보_모음, 기준일, 검색범위, 0)
}

func F고점_찾기(일일가격정보_모음 *공통.S일일가격정보_모음, 기준일 time.Time, 검색범위 int) (error, *공통.C일일가격정보) {
	return F고점_찾기_선행기간_확인(일일가격정보_모음, 기준일, 검색범위, 1)
}

func F고점_찾기_선행기간_확인(일일가격정보_모음 *공통.S일일가격정보_모음,
	기준일 time.Time, 검색범위 int, 선행기간 int) (error, *공통.C일일가격정보) {
	if 검색범위 <= 0 {
		에러 := fmt.Errorf("F고점_찾기_선행기간_확인() : 검색범위가 0 혹은 음수입니다. 검색범위 : %v", 검색범위)

		return 에러, nil
	}

	if 선행기간 < 0 {
		에러 := fmt.Errorf("F고점_찾기_선행기간_확인() : 선행기간이 음수입니다. 선행기간 : %v", 선행기간)

		return 에러, nil
	}

	시작시점 := 기준일.AddDate(0, 0, -1*검색범위)
	종료시점 := 기준일

	에러, 고점 := 고점_찾기_도우미(일일가격정보_모음, 시작시점, 종료시점)

	if 에러 != nil {
		return 에러, nil
	}

	// 선행고점에 무관한 단순 고점 찾기일 경우 여기서 종료.
	if 선행기간 == 0 {
		return nil, 고점
	}

	// 최고조정가 초기화
	var 최고조정가 float64 = 0.0

	if 고점.G조정시가() > 고점.G조정종가() {
		최고조정가 = 고점.G조정시가()
	} else {
		최고조정가 = 고점.G조정종가()
	}

	// 현재 고점이 선행기간 동안에도 고점인지 확인.
	for 반복횟수 := 0; 반복횟수 < 1000; 반복횟수++ {
		for 선행기간_확장 := 0; 선행기간_확장 < 1000; 선행기간_확장++ {
			시작시점 = 고점.G일자().AddDate(0, 0, -1*(선행기간+선행기간_확장))
			종료시점 = 고점.G일자()

			if !종료시점_이전에_정상적인_가격데이터_존재여부_확인(일일가격정보_모음, 시작시점, 종료시점) {
				// 정상가격정보 없음. 선행기간 늘려서 재검색
				continue
			}

			에러, 신고점 := 고점_찾기_도우미(일일가격정보_모음, 시작시점, 종료시점)

			if 에러 != nil {
				log.Println("F고점_찾기_선행기간_확인(). 고점_찾기_도우미() 호출 후 에러발생. 반복횟수", 반복횟수, ", 선행기간_확장", 선행기간_확장)
				return 에러, nil
			}

			if 최고조정가 >= 신고점.G조정시가() &&
				최고조정가 >= 신고점.G조정종가() {
				// 현재 고점이 진짜 고점이 맞음
				return nil, 고점
			}

			// 새로운 고점을 찾았음.
			// 고점과 최고조정가를 새로 설정한 후, 처음부터 다시 선행고점 있는 지 확인
			고점 = 신고점

			if 고점.G조정시가() > 고점.G조정종가() {
				최고조정가 = 고점.G조정시가()
			} else {
				최고조정가 = 고점.G조정종가()
			}
		}
	}

	// 고점을 못 찾았음.
	에러 = errors.New("F고점_찾기_선행기간_확인() : 선행기간을 만족하는 고점을 찾지 못함.")

	return 에러, nil
}
