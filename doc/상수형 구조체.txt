상수형이 필요한 이유.

동시처리(concurrent) 모듈에서 공유되는 정보는 여러 모듈이 동시에 변경하고 읽을 경우 경쟁조건(racing condition)이 발생할 가능성을 가지고 있다.
이러한 동시처리 문제는 세마포어, 락 등 여러가지 방법이 존재하지만 여전히 근본적인 해결이 쉽지 않은 문제로 알려져 있다.
Go 언어는 서로 자료를 공유하지 않는 "독립된" go루틴 간에 채널(channel)을 통해서 정보를 주고 받음으로서 이 문제를 근본적으로 해결할 수 있다고 주장한다. (CSP원리?)
그러나, 채널을 통해서 전달되는 변수의 유일성(uniqueness)을 보장하는 것은 여전히 프로그래머의 몫이다.
채널을 통해서 전달되는 변수의 유일성을 보장하는 것은 정보의 내용을 통째로 복사해서 전달하는 방법(passing by value)가 가장 근원적이지만,
이 경우 메모리 낭비가 심한 단점이 있으며, 참조형(reference type) 데이터는 복사해서 전달해도, 참조형이 가리키는 내용은 공유되므로, go루틴의 독립성이 보장되지 못한다.
(Go언어에서 포인터, 슬라이스, 맵, 채널, 인터페이스등이 참조형(reference type) 데이터이다.)
이렇게 메모리 낭비와 참조형 복사 문제를 해결하기 위해서 생각한 방법이 내용을 변경할 수 없는(immutable) 데이터의 포인터를 복사해서 주고 받는 것이다.
포인터만 주고 받으니 메모리 낭비가 적고, 포인터가 복사되었으니 각 포인터 간에 독립성이 보장되며, 포인터가 가리키는 내용을 변경할 수 없으니, 참조형이 복사되어도 각 go루틴의 독립성이 보장된다.
만약, 각 go루틴이 채널을 통해서 전달받은 정보를 가공(혹은 변경)해서 사용해야 할 경우, 그 내용을 복사해서 새로운 변수에 할당한 후 복사본을 가공해서 사용하면 된다.

트위터에서 고성능 동시처리 구현에 사용하면서 유명해진 Scala의 경우 상수형(immutable) 자료구조와 변경가능한(mutable) 자료구조를 철저하게 나누어서 제공하지만,
Go언어는 언어자체적으로 제공하지는 않으며, 구조체(struct)의 멤버 변수는 숨긴 채, 공개 메소드를 통해서 읽을 수만 있게 하는 방식으로 변경불가능하게 만들어서 써야 한다.
구조체의 내부 멤버변수를 숨겨서 직접 변경할 수 없게 하며, 멤버변수를 읽는 메소드는 제공하지만, 멤버변수를 변경하는 메소드는 제공하지 않음으로써, 일단 생성한 이후에는 값을 변경할 수 없거나,
값을 변경하더라도 다른 곳에는 영향을 주지 않는 독립성을 보장한다.
이렇게 내용을 변경할 수 없거나(immutable) 한 곳에서 변경하더라도 다른 곳에 영향을 미치지 않도록 보장하는 데이터를 Go언어의 struct를 통해서 구현한 것을 앞으로 
"상수형 구조체"라 부르기로 하고, 이름 첫글자를 C로 시작하여서 구분짓기로 한다.

- 정수, 실수, 문자열, 시점등의 "기본형 상수형 구조체"를 우선 구현.
- 기본형 상수형 구조체를 토대로 여러 구성요소를 조합한 "파생형 상수형 구조체"를 구성할 수 있으며 그 구성요소는 다음과 같다.
  1. "기본형 상수형 구조체"의 포인터
  2. 다른 "파생형 상수형 구조체"의 포인터
  3. 인터페이스(interface), 채널(channel), 슬라이스(slice)
     : 참조형(reference type) 변수이지만, Go언어의 값에 의한 전달(passing by value) 원칙에 의해서 복사본이 전달되므로, 각 go루틴에서 변경하더라도 서로 간에 독립성이 보장됨.
     : 참고로 슬라이스(slice)는 복사본이 전달되며, 비록 변경이 가능하지만, 한 곳에서 내용을 변경하더라도 다른 곳에서 영향을 미치지 않고 독립성이 유지된다. (실제 테스트를 수행해 봤음)
	(연습 패키지의 "구조체_멤버_슬라이스와_맵의_독립성_테스트.go"를 참조.)
  4. 상수형 구조체의 포인터로 이루어진 맵(map) => 비추천. 독립성을 유지하기 어려움.
     : 테스트 결과 맵은 값에 의한 전달(passing by value) 원칙에 의해서 맵의 복사본이 전달되더라도, 한 곳에서 맵 내용을 변경하면 다른 곳에도 영향을 미친다.
	(연습 패키지의 "구조체_멤버_슬라이스와_맵의_독립성_테스트.go"를 참조.)
      이것은 앞서 언급한 참조형(reference type) 데이터를 복사해도 그 내용이 공유되는 문제이다.
      그러므로, 상수형 구조체에 맵을 사용하면 go루틴 간의 독립성이 깨어진다.
      되도록 맵을 사용하지 말고 슬라이스(slice)를 사용하되, 반드시 맵을 사용해야 한다면 맵을 주고 받을 때는 항상 새로운 맵을 생성하고 내용을 복사해서 독립성을 확보한 후 사용해야 한다.
      이것은 세심한 주의를 필요로 하며, 자칫 실수하면 (go루틴 간에 독립성이 사라지고) 악명높은 경쟁조건(racing condition)이 발생할 수 있다.
      (맵을 주고 받을 때의 구체적 의미 : 줄 때(메소드에서 리턴할 때), 받을 때(상수형 구조체를 생성할 때) `)
 