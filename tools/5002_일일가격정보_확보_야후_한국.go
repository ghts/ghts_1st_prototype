package tools

import (
	"bytes"
	"encoding/csv"
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	공통 "pts/common"
	"strconv"
	"strings"
	"time"
)

// 테스트할 때는 도우미를 MOCK-UP(모의 데이터)으로 교체함.
var 일일가격정보_불러오기_도우미 = 일일가격정보_불러오기_도우미_야후_한국

var 에러내역_맵 *공통.S종목코드별_에러내역_맵 = new(공통.S종목코드별_에러내역_맵)

func F전종목_일일가격정보_확보() *공통.S종목코드별_에러내역_맵 {
	종목정보_맵, 에러 := 공통.F종목정보_맵()
	if 에러 != nil {
		log.Println("tools.F전종목_일일가격정보_확보() : common.F종목정보_맵() 에러.", 에러)
	}

	종목정보_모음 := make([]*공통.C종목, 0)
	오류발생_종목정보_모음 := make([]*공통.C종목, 0)

	// 처음에는 모든 종목으로 시작한다.
	for _, 종목정보 := range 종목정보_맵 {
		종목정보_모음 = append(종목정보_모음, 종목정보)
	}

	for 반복횟수 := 0; 반복횟수 < 5; 반복횟수++ {
		for _, 종목정보 := range 종목정보_모음 {
			log.Printf("종목코드 %v, 종목명칭 %v", 종목정보.G종목코드(), 종목정보.G종목명칭())

			에러 := F종목별_일일가격정보_확보(종목정보)
			if 에러 != nil {
				log.Println("------------------------------")
				log.Println(에러)
				log.Println("------------------------------")

				오류발생_종목정보_모음 = append(오류발생_종목정보_모음, 종목정보)
			}
		}

		// 오류가 발생한 종목에 대해서만 재시도
		종목정보_모음 = 오류발생_종목정보_모음
		오류발생_종목정보_모음 = make([]*공통.C종목, 0)
	}

	// 5회 재시도 후에도 남은 오류발생 종목들에 관한 기록 보여주기
	log.Println("")
	log.Println("-----------------------------------")
	log.Println("일일가격정보 확보 중 오류가 발생한 종목 기록.")
	log.Println("-----------------------------------")
	log.Println("")

	에러내역_맵.F에러내역_출력()

	return 에러내역_맵
}

func F종목별_일일가격정보_확보(종목 *공통.C종목) error {
	// 1. 기존 데이터가 없는 경우 1900-01-01부터 모든 데이터를 불러온다.
	// 2. 기존 데이터가 있는 경우 가장 최근 데이터 일자를 포함한 그 이후 데이터만 불러온다.
	// 3. 가장 최근 데이터의 조정종가가 변했을 경우,
	//		기존에 존재하던 모든 데이터를 불러와서 조정종가를 포함한 조정가격을 수정한다.

	// 상장주식의 단축코드는 A로 시작한다.
	// 주식코드만 고려하자.
	if !strings.HasPrefix(종목.G종목코드(), "A") {
		log.Println("tools.F종목별_일일가격정보_확보() : "+
			"종목코드가 상장주식이 아니어서 건너뜀.", 종목.G종목코드())

		return nil
	}

	종목 = 공통.F종목검색(종목.G종목코드())

	기존_일일가격정보_모음, 에러 := 공통.F종목별_일일가격정보_모음(종목)
	if 에러 != nil {
		log.Printf("tools.F종목별_일일가격정보_확보() : common.F종목별_일일가격정보_모음() 에러. 종목코드 %v. %v", 종목.G종목코드(), 에러)

		return 에러
	}

	시작일_기본값, _ := 공통.F문자열2일자("1900-01-01")
	시작일 := 시작일_기본값
	종료일 := time.Now()

	if 기존_일일가격정보_모음.G수량() > 0 {
		sql := new(bytes.Buffer)
		sql.WriteString("SELECT")
		sql.WriteString("	MAX(priced_on) ")
		sql.WriteString("FROM " + 공통.F일일가격정보_테이블() + " ")
		sql.WriteString("WHERE stock_info_id = ?")

		시작일, 에러 = 공통.F_SQL질의_시점(sql.String(), 종목.G식별코드())
		if 에러 != nil {
			log.Println("tools.F종목별_일일가격정보_확보() : common.F_SQL질의_시점() 에러.", 에러, sql.String())

			return 에러
		}
	}

	종목별_일일가격정보_모음, 에러 := 종목별_일일가격정보_확보_도우미_통합(종목, 시작일, 종료일)
	if 에러 != nil {
		return 에러
	}

	if 기존_일일가격정보_모음.G수량() > 0 {
		기존_일일가격정보 := 기존_일일가격정보_모음.G일일가격정보(시작일)
		일일가격정보 := 종목별_일일가격정보_모음.G일일가격정보(시작일)

		if 기존_일일가격정보 == nil {
			log.Println("tools.F종목별_일일가격정보_확보() : '기존_일일가격정보_시작일'가 nil 입니다.")
		} else if 일일가격정보 == nil {
			log.Println("tools.F종목별_일일가격정보_확보() : '일일가격정보_시작일'가 nil 입니다.")
		} else if 기존_일일가격정보.G조정종가() != 일일가격정보.G조정종가() {
			종료일 = 시작일.AddDate(0, 0, -1)
			시작일 = 시작일_기본값

			종목별_일일가격정보_모음_추가, 에러 := 종목별_일일가격정보_확보_도우미_통합(종목, 시작일, 종료일)
			if 에러 != nil {
				return 에러
			}

			종목별_일일가격정보_모음.S추가(종목별_일일가격정보_모음_추가.G슬라이스())
		}
	}

	에러 = 공통.F일일가격정보_모음_DB기록(종목별_일일가격정보_모음)
	if 에러 != nil {
		log.Println("tools.F종목별_일일가격정보_확보() : common.F일일가격정보_모음_DB기록() 에러.", 에러)

		에러내역 := 공통.F에러내역_생성("F일일가격정보_모음_DB기록()", 에러.Error())
		에러내역_맵.S에러내역_추가(종목.G종목코드(), 에러내역)

		return 에러
	}

	// 각 종목 사이에 일정시간 간격을 두어서 일일가격정보 제공 서버의 부담을 줄인다.
	// 무료 서비스를 이용하면서 서버에 과도한 부하를 거는 것은 예의가 아닌 듯.
	if !공통.F테스트_모드() {
		time.Sleep(2000 * time.Millisecond)
	}

	return nil
}

func 종목별_일일가격정보_확보_도우미_통합(
	종목 *공통.C종목,
	시작일 time.Time,
	종료일 time.Time) (*공통.S종목별_일일가격정보_모음, error) {

	일일가격정보_문자열_모음, 에러 := 일일가격정보_불러오기_도우미(종목, 시작일, 종료일)
	if 에러 != nil {
		에러내역 := 공통.F에러내역_생성("일일가격정보_불러오기_도우미",
			종목.G종목코드()+" "+
				공통.F일자2문자열(시작일)+" "+
				공통.F일자2문자열(종료일)+" "+
				에러.Error())
		에러내역_맵.S에러내역_추가(종목.G종목코드(), 에러내역)

		return nil, 에러
	}

	종목별_일일가격정보_모음, 에러 := 종목별_일일가격정보_모음_생성_도우미(종목, 일일가격정보_문자열_모음)
	if 에러 != nil {
		에러내역 := 공통.F에러내역_생성("종목별_일일가격정보_모음_생성_도우미",
			종목.G종목코드()+" "+
				공통.F일자2문자열(시작일)+" "+
				공통.F일자2문자열(종료일)+" "+
				에러.Error())
		에러내역_맵.S에러내역_추가(종목.G종목코드(), 에러내역)

		return nil, 에러
	}

	return 종목별_일일가격정보_모음, nil
}

func 일일가격정보_불러오기_도우미_야후_한국(
	종목 *공통.C종목,
	시작일 time.Time,
	종료일 time.Time) ([][]string, error) {
	var 에러코드, 에러설명 string

	URL요청문자 := 야후_한국_URL문자열_생성(종목, 시작일, 종료일)

	응답, 에러 := http.Get(URL요청문자)

	if 에러 != nil {
		if 응답 != nil {
			defer 응답.Body.Close() // panic이 발생하면 하지 말 것.
		}

		에러코드 = "HTTP에러 (" + 종목.G종목코드() + " " + 종목.G종목명칭() + ")"
		에러설명 = 에러.Error()

		에러내역 := 공통.F에러내역_생성(에러코드, 에러설명)
		에러내역_맵.S에러내역_추가(종목.G종목코드(), 에러내역)

		// HTTP요청이 너무 과도하면 서버(야후! 금융)가 해당 IP를 일시적으로 차단한다.
		// HTTP 에러가 발생했으므로 서버가 차단했다고 판단하고,
		//  차단상태가 해제가 될 때까지 잠시 기다린다.
		time.Sleep(30 * time.Second)

		return nil, 에러
	}

	defer 응답.Body.Close()

	// 디버깅용 내용출력
	//fmt.Println(URL요청문자.String())

	레코드_모음, 에러 := csv.NewReader(응답.Body).ReadAll()

	if 에러 != nil {
		// 상장폐지 및 기타종목은 에러가 나도 무시하고 넘어간다.
		// 야후금융은 상장폐지 종목 데이터는 없는 경우가 대부분(혹은 전부)이다.
		if strings.Contains(종목.G시장구분(), "상장폐지") ||
			strings.Contains(종목.G시장구분(), "기타") {
			return nil, 에러
		}

		// 응답내용 확인해서 디버깅 시도.
		if 응답.Body == nil {
			에러설명 = "HTTP 응답.Body가 nil입니다."
		} else {
			응답내용, 에러 := ioutil.ReadAll(응답.Body)

			if 에러 != nil {
				에러설명 = "HTTP 응답내용 읽기 에러."
			} else {
				if len(응답내용) == 0 {
					에러설명 = "HTTP 응답내용이 비어있습니다."
				} else {
					응답내용_문자열 := string(응답내용)

					if strings.Contains(응답내용_문자열,
						"the page you requested was not found.") {
						에러설명 = "HTTP페이지를 찾을 수 없습니다."
					} else {
						에러설명 = "HTTP 응답 : " + 응답내용_문자열
					}
				}
			}
		}

		에러내역 := 공통.F에러내역_생성("CSV읽기 에러", 에러설명)
		에러내역_맵.S에러내역_추가(종목.G종목코드(), 에러내역)

		// CSV 에러가 난 경우에도 서버 측 일시차단 된 경우가 있으므로 5초 간 쉰다.
		time.Sleep(5 * time.Second)

		// 재귀호출(스스로를 호출)해서 재시도
		return nil, 에러
	}

	// 가격데이터가 없거나, CSV로 해석불가능하면 무시
	if len(레코드_모음) < 1 {
		에러 := errors.New("CSV 읽은 후 레코드 갯수가 0임. (" +
			종목.G종목코드() + " " +
			종목.G종목명칭() + ")")

		에러내역 := 공통.F에러내역_생성("CSV읽기 에러", 에러.Error())
		에러내역_맵.S에러내역_추가(종목.G종목코드(), 에러내역)

		return nil, 에러
	}

	// 첫째 줄(레코드_모음[0])은  제목이라서 제거한다.
	레코드_모음 = 레코드_모음[1:]

	return 레코드_모음, nil
}

func 야후_한국_URL문자열_생성(종목 *공통.C종목, 시작일 time.Time, 종료일 time.Time) string {
	var 시장구분 string

	if strings.Contains(종목.G시장구분(), "유가증권시장") {
		시장구분 = ".KS" // 유가증권 시장
	} else if strings.Contains(종목.G시장구분(), "코스닥") {
		시장구분 = ".KQ" // 코스닥 시장
	}

	종목코드_문자열 := strings.TrimPrefix(종목.G종목코드(), "A") + 시장구분
	종목코드_문자열 = url.QueryEscape(종목코드_문자열)

	기본URL주소 := "http://ichart.yahoo.com/table.csv?s="

	연도_시작, 월_시작, 일_시작 := 야후_연월일_문자열(시작일)
	연도_종료, 월_종료, 일_종료 := 야후_연월일_문자열(종료일)

	일일가격정보형식 := "g=d"
	//주간데이터형식 := "g=w"
	//월간데이터형식 := "g=m"

	CSV형식 := "ignore=.csv"

	var URL요청문자 bytes.Buffer
	URL요청문자.WriteString(기본URL주소)
	URL요청문자.WriteString(종목코드_문자열)
	URL요청문자.WriteString("&a=" + 월_시작)
	URL요청문자.WriteString("&b=" + 일_시작)
	URL요청문자.WriteString("&c=" + 연도_시작)
	URL요청문자.WriteString("&d=" + 월_종료)
	URL요청문자.WriteString("&e=" + 일_종료)
	URL요청문자.WriteString("&f=" + 연도_종료)
	URL요청문자.WriteString("&" + 일일가격정보형식)
	URL요청문자.WriteString("&" + CSV형식)

	return URL요청문자.String()
}

func 야후_연월일_문자열(일자 time.Time) (연도 string, 월 string, 일 string) {
	연도_정수, 월_정수, 일_정수 := 공통.F연월일_정수(일자)

	// Yahoo! Finanace API규격상 월(Month)은 1을 빼주어야 한다고 함. Java도 이런 식이라서 엄청 헷갈렸는 데.
	// (참고자료 : https://code.google.com/p/yahoo-finance-managed/wiki/csvHistQuotesDownload)
	연도 = strconv.Itoa(연도_정수)
	월 = strconv.Itoa(월_정수 - 1)
	일 = strconv.Itoa(일_정수)

	return 연도, 월, 일
}

func 종목별_일일가격정보_모음_생성_도우미(
	종목 *공통.C종목,
	레코드_모음 [][]string) (*공통.S종목별_일일가격정보_모음, error) {
	일일가격정보_모음 := make([]*공통.C일일가격정보, 0)
	날짜형식 := "2006-01-02"

	for _, 레코드 := range 레코드_모음 {
		일자, 에러 := time.Parse(날짜형식, 레코드[0])
		if 에러 != nil {
			log.Println("종목별_일일가격정보생성_도우미() : time.Parse() 에러 발생.")
			return nil, 에러
		}

		시가, 에러 := 공통.F문자열2실수64(레코드[1])
		if 에러 != nil {
			log.Println("종목별_일일가격정보생성_도우미() : 시가 공통.F문자열2실수64() 에러 발생.")
			return nil, 에러
		}

		고가, 에러 := 공통.F문자열2실수64(레코드[2])
		if 에러 != nil {
			log.Println("종목별_일일가격정보생성_도우미() : 고가 공통.F문자열2실수64() 에러 발생.")
			return nil, 에러
		}

		저가, 에러 := 공통.F문자열2실수64(레코드[3])
		if 에러 != nil {
			log.Println("종목별_일일가격정보생성_도우미() : 저가 공통.F문자열2실수64() 에러 발생.")
			return nil, 에러
		}

		종가, 에러 := 공통.F문자열2실수64(레코드[4])
		if 에러 != nil {
			log.Println("종목별_일일가격정보생성_도우미() : 종가 공통.F문자열2실수64() 에러 발생.")
			return nil, 에러
		}

		거래량, 에러 := 공통.F문자열2실수64(레코드[5])
		if 에러 != nil {
			log.Println("종목별_일일가격정보생성_도우미() : 거래량 공통.F문자열2실수64() 에러 발생.")
			return nil, 에러
		}

		조정종가, 에러 := 공통.F문자열2실수64(레코드[6])
		if 에러 != nil {
			log.Println("종목별_일일가격정보생성_도우미() : 조정종가 공통.F문자열2실수64() 에러 발생.")
			return nil, 에러
		}

		일일가격정보 := new(공통.S일일가격정보)
		일일가격정보.S종목(종목)
		일일가격정보.S일자(일자)
		일일가격정보.S시가(시가)
		일일가격정보.S고가(고가)
		일일가격정보.S저가(저가)
		일일가격정보.S종가(종가)
		일일가격정보.S거래량(거래량)
		일일가격정보.S조정종가(조정종가)
		일일가격정보.M조정가격_재계산()

		일일가격정보_모음 = append(일일가격정보_모음, 일일가격정보.G상수형_구조체())
	}

	일일가격정보_모음_반환값 := new(공통.S종목별_일일가격정보_모음)
	일일가격정보_모음_반환값.S종목(종목)
	일일가격정보_모음_반환값.S추가(일일가격정보_모음)

	return 일일가격정보_모음_반환값, nil
}

/*
func CSV파일_기록_도우미(
	종목 *공통.C종목,
	레코드_모음 [][]string) error {
	파일이름 := 종목.G종목코드() + "_" +
		종목.G종목명칭() + "_" +
		레코드_모음[0][0] + ".csv"
	파일, 에러 := os.Create(파일이름)

	if 에러 != nil {
		log.Println(에러)
		return 에러
	}
	defer 파일.Close()

	에러 = csv.NewWriter(파일).WriteAll(레코드_모음)

	return 에러
}
*/
