package server

import (
	공통 "pts/common"
	"runtime"
	"time"
)

type S전략그룹관리 struct {
	전략그룹모음 []공통.I전략그룹          // 서버와 정보를 교환할 전략그룹들.
	회신채널모음 [](chan []공통.I전략그룹) // 구독을 신청한 모듈들에게 정보를 전송할 채널들

	전략그룹등록채널 chan 공통.I전략그룹          // 서버의 관리를 받고자 하는 전략들이 등록하는 채널
	구독신청채널   chan (chan []공통.I전략그룹) // 서버 모듈이 데이터 구독 신청하는 채널
	공통이벤트채널  chan int8

	전략그룹정보전송_처리권한 chan int8
}

func (s *S전략그룹관리) G공통이벤트채널() chan int8 { return s.공통이벤트채널 }

func (s *S전략그룹관리) M실행(설정 *C서버설정) {
	설정.G종료대기열().Add(1)
	defer 설정.G종료대기열().Done()

	s.초기화(설정)

	for {
		select {
		case 전략그룹 := <-s.전략그룹등록채널:
			s.전략그룹모음 = append(s.전략그룹모음, 전략그룹)
			s.전략그룹정보전송_전체(전략그룹)
		case 회신채널 := <-s.구독신청채널:
			s.회신채널모음 = append(s.회신채널모음, 회신채널)
			s.전략그룹정보전송_단일(회신채널, s.전략그룹모음)
		case 이벤트 := <-s.공통이벤트채널:
			switch 이벤트 {
			case 공통.비상탈출이벤트:
				s.공통이벤트전송(이벤트)
			case 공통.종료이벤트:
				s.공통이벤트전송(이벤트)
				runtime.Goexit() // 모듈 종료
			default:
				panic("S전략그룹관리.M실행() : 예상치 못한 공통 이벤트.")
			}
		default:
			// 자주 실행되는 게 아니니 대기시간을 조금 길게 잡자.
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func (s *S전략그룹관리) 초기화(설정 *C서버설정) {
	s.전략그룹모음 = make([]공통.I전략그룹, 100)
	s.회신채널모음 = make([](chan []공통.I전략그룹), 100)

	s.전략그룹등록채널 = 설정.G전략그룹등록채널()
	s.구독신청채널 = 설정.G전략그룹구독신청채널()
	s.공통이벤트채널 = make(chan int8, 10)

	// 채널을 세마포어처럼 이용해서 최대 동시처리 숫자를 조절하는 패턴 (Effective Go 참조)
	전략그룹정보전송_최대동시처리숫자 = 100
	s.전략그룹정보전송_처리권한 = make(chan int8, 전략그룹정보전송_최대동시처리숫자)
}

func (s *S전략그룹관리) 전략그룹정보전송_전체() {
	var 채널 chan []공통.I전략그룹

	for _, 채널 = range s.회신채널모음 {
		<-s.전략그룹정보전송_처리권한 // 처리권한 획득
		go s.전략그룹정보전송_도우미(채널, s.전략그룹모음)
	}
}

func (s *S전략그룹관리) 전략그룹정보전송_단일(채널 chan []공통.I전략그룹) {
	<-s.전략그룹정보전송_처리권한 // 처리권한 획득
	go s.전략그룹정보전송_도우미(채널, s.전략그룹모음)
}

// 별도의 펑션으로 분리하면 인수가 전달되면서 자동으로 복사본이 생성되고,
// go루틴은 그 복사본을 사용하게 되므로 go루틴의 독립성이 보장된다.
func 전략그룹정보전송_도우미(
	채널 chan []공통.I전략그룹,
	정보 []공통.I전략그룹) {
	채널 <- 정보
	s.전략그룹정보전송_처리권한 <- 1 // 처리권한 반환.
}

func (s *S전략그룹관리) 공통이벤트전송(이벤트 int8) {
	이벤트전송 := 공통.F이벤트전송

	var 전략그룹 공통.I전략그룹
	for _, 전략그룹 = range s.전략그룹모음 {
		// 모든 전략그룹에게 해당 이벤트 전송.
		이벤트전송(전략그룹.G공통이벤트채널(), 이벤트)
	}
}
